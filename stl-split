#!/usr/bin/env python3

"""
Split an stl file.

The idea is to help post-processing stl files made with mapelia, so they
can be printed more easily. It does not modify the original file, but
creates two new files that end with "_N.stl" and "_S.stl"
(or "_head.stl" and "_tail.stl" if using the option --number).
"""

import sys
import os
import struct

from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter as fmt

from maps import check_if_exists

red = lambda txt: '\x1b[31m%s\x1b[0m' % txt


def main():
    args = get_args()

    if not os.path.isfile(args.file):
        sys.exit('File %s does not exist.' % args.file)

    if not valid_stl(args.file):
        if args.ignore_check:
            print('Going ahead anyway as you used --ignore-check ...')
        else:
            sys.exit('Cancelling (use --ignore-check to force processing it).')

    find_class = class_selector(args.number, args.zcut, args.file)

    name = args.name or args.file.rsplit('.', 1)[0]
    for tclass, triangles in extract_triangles(args.file, find_class).items():
        output = '%s_%s.stl' % (name, tclass)
        if not args.overwrite:
            check_if_exists(output)
        write_stl(output, triangles)


def get_args():
    "Return the parsed command line arguments"
    parser = ArgumentParser(description=__doc__, formatter_class=fmt)
    add = parser.add_argument  # shortcut
    add('file', help='stl file')
    add('-n', '--name', default='',
        help='output file (if empty, it is generated from the image file name)')
    add('--zcut', default='0', help='z value of the cutting xy-plane (or auto)')
    add('--number', type=int, default=0,
        help='split by leaving a given number of triangles in the first file')
    add('--overwrite', action='store_true',
        help='do not check if the output files already exist')
    add('--ignore-check', action='store_true',
        help='go ahead even if the input file does not look like an stl')
    return parser.parse_args()


def valid_stl(fname):
    "Return True if file looks like an stl, warn and return False otherwise"
    if not fname.endswith('.stl'):  # soft warning
        print(red('File %s does not end in ".stl". Is it really an stl file?' %
                  fname))

    ntriangles = struct.unpack('<I', open(fname, 'rb').read(84)[-4:])[0]
    size_content = os.path.getsize(fname) - 84  # 84 = header + number
    size_triangle = (1 * 3 + 3 * 3) * 4 + 2  # 4 bytes per float
    # 1 normal vector, 3 vertices (with 3 components each), 2 dummy bytes
    if size_content / size_triangle == ntriangles:
        return True
    else:
        print(red('File %s does not look like an stl file:\n'
                  '  It declares to have %d triangles but has capacity for %g.'
                  % (fname, ntriangles, size_content / size_triangle)))
        return False


def get_zcut(zcut, fname):
    "Return the z value where the hemispheres will be cut"
    try:
        return float(zcut)
    except ValueError:
        if zcut == 'auto':
            return z_mean(fname)
        else:
            sys.exit('zcut can be "auto" or a float.')


def z_mean(fname):
    "Return the mean z of all the triangles in the stl file fname"
    z, n = 0, 0
    for triangle in get_triangles(fname):
        _, _, v1_z, _, _, v2_z, _, _, v3_z = unpack(triangle)
        z = (n * z + v1_z + v2_z + v3_z) / (n + 3)
        n += 3
    return z


def get_triangles(fname):
    "Yield raw-data triangles in file fname"
    with open(fname, 'rb') as fin:
        fin.read(84)  # discard header + number of triangles
        size_triangle = 12 * 4 + 2  # 12 floats and 2 dummy bytes
        yield from iter(lambda: fin.read(size_triangle), b'')


def unpack(triangle):
    "Return x, y, z from the 3 points that define the raw-data triangle"
    return struct.unpack('<9f', triangle[12:48])


def class_selector(number, zcut_arg, fname):
    "Return function that, given a number and a triangle, returns its class"
    if number == 0:
        zcut = get_zcut(zcut_arg, fname)
        def find_class(n, triangle):
            _, _, v1_z, _, _, v2_z, _, _, v3_z = unpack(triangle)
            if min(v1_z, v2_z, v3_z) >= zcut:
                return 'N'
            elif max(v1_z, v2_z, v3_z) <= zcut:
                return 'S'
            else:
                return 'discarded'
    else:
        def find_class(n, triangle):
            return 'head' if n < number else 'tail'

    return find_class


def extract_triangles(fname, find_class):
    "Return dict with the triangles belonging to each class of stl file fname"
    print('Processing file %s ...' % fname)
    triangles = {}
    for i, triangle in enumerate(get_triangles(fname)):
        tclass = find_class(i, triangle)  # N, S, head, tail...
        triangles.setdefault(tclass, []).append(triangle)
    return triangles


def write_stl(fname, triangles):
    "Write binary-encoded list of triangles as an stl file"
    print('Writing file %s ...' % fname)
    with open(fname, 'wb') as fout:
        fout.write(b'\0' * 80)  # header (empty)
        fout.write(struct.pack('<I', len(triangles)))  # number of triangles
        for triangle in triangles:
            fout.write(triangle)


def find_border(triangles):
    "Return the points that form part of at most 2 triangles"
    appearances = {}
    for triangle in triangles:
        for i in range(3):
            start = 12 + i * 12
            p = struct.unpack('<3f', triangle[start:start+12])
            appearances.setdefault(p, 0)
            appearances[p] += 1
    return [p for p, n in appearances.values() if n < 3]



if __name__ == '__main__':
    main()
